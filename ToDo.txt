### TO DO Y PLAN GENERAL ###

# ÍTEM ACTUAL #

* Pulir informativos del Menú *
 - Hasta ahora los botones del menú guía básica, instrucciones, faq, readme y acerca de, llevan a sus propios html respectivos en la carpeta public/info/.
 - Ver la posibilidad de que todos estos usen un mismo html, llevandolos a sus sección respectiva.
  - NOTA: Verificar que ningún HTML dentro de public/info/ incluya scripts inline para cumplir CSP, aunque con el setup actual no genera problemas.

# Más adelante #

* Internacionalización *
- Agregar soporte multilenguaje
- Selector de idioma en el menú
En renderer.js tenemos este helper:

function setIdiomaActual(nuevoIdioma) {
  if (typeof nuevoIdioma === "string" && nuevoIdioma.length > 0) {
    idiomaActual = nuevoIdioma;
  }
}
- Archivos de 18i.

* Implementar semiauto-update *

* Revisión y depuración del código *

* Integración a extensiones de navegadores *

* Atajos del teclado *
- Actualmente tenemos un botón de Short-cuts en el menú que no está funcional.
- Habilitar este botón para que abra una lista de shortcuts del teclado que sea editable por el usuario.
- ¿Atajos del teclado sin focus en la ventana principal?

* Nuevas funciones *

- Extractores de caracteres y palabras en:
  - Archivos de imagen:
    - Ejemplo: foto de una página común de un libro
    - Esto permitiría hacer una función que estime el total del libro tras:
      - Preguntar cantidad de páginas totales del libro
      - Copiar el texto extraido al portapapeles
      - Usar funcion "Pegar portapapeles nueva línea" la misma cantidad de iteraciones que las páginas del libro.
    - posibilidad de sacar una foto mediante la camara del dispositivo
  - archivos de texto:
    - formatos simples (txt, doc, docx, rtf, etc)
    - formatos complejos como pdf:
      - con texto seleccionable
      - sin texto seleccionable:
        - hechos de imagenes
        - protegido
  - (Averiguar sistema OCR como extractor de palabras)

- Test de velocidad de lectura:
  - Al abrir este test, primero se informa al usuario en que consiste (avisando que se sobrescribirá el texto vigente, entre otras cosas).
  - Se le ofrece un botón para comenzar. El botón:
    - Abre una ventana con un texto aleatorio (entre un pool de textos) de dificultad normal pensado para que un lector adulto promedio lo lea en 2 minutos.
    - El mismo texto sobrescribe el texto vigente de la app (lo mismo que hace el botón "Sobrescribe con portapapeles" con los textos en portapapeles).
    - Comienza inmediatamente a correr el cronómetro de la app (lo mismo que hace el botón "Start" o play/pause toggle).
  - El usuario al finalizar la lectura puede pulsar un botón de finalizar. El botón:
    - Detiene el cronómetro de la app y calcula (lo mismo que hace el botón "Stop/Calcular" play/pause toggle).
    - Agrega al input WPM de la sección Velocidad de lectura el WPM calculado.
    - Abre el modal de creación de presets (misma acción que el botón "Nuevo") con prerrellenado editable que dice:
      Nombre: Test
      WPM: se deja que sea el mismo que el input, como lo hace el botón Nuevo normalmente.
      Descripción: Velocidad testeada del usuario.
    - El usuario puede modificar, guardar y cerrar el modal, con las mismas consecuencias que tiene toda creación de Nuevo preset.

* Estilos/skins *

* Mejorar Readme * 
- listar bugs (o crear un archivo nuevo de bugs)
- mudar changelog a nuevo archivo

* Revisar seguridad de la aplicación y legalidad *
 - Licencia de la fuente kremlin duma para logo Cibersin

* Habilitar botones faltantes del menú *

- Herramientas
  - Cargador de archivo de textos
  - Contador de palabras en imágenes
  - Test de velocidad de lectura
- Preferencias
  - Idioma
  - Diseño
    - Skins
	  - Ventana flotante (seleccionar ubicación y transparencia)
	  - Fuentes (fuente y tamaño letra. general, ventana texto completo, ventana flotante.)
	  - Colores (fondo de cada ventana, etc)
  - Shortcuts (cambiar el del portapapeles por defecto, start/stop cronómetro, activación/desactivación ventana flotante)
  - Presets por defecto (abre carpeta presets)
- Comunidad
  - Discord
  - Avisos y novedades
- Links de interés
- COLABORA ($)
- ?
  - Actualizar a última versión

* Actualización de botones informativos del menú *
- Modificar htmls de los botones con información: guía básica, instrucciones, faq, readme y acerca de.
  - NOTA: Verificar que ningún HTML dentro de public/info/ incluya scripts inline para cumplir CSP, aunque con el setup actual no genera problemas.

* Revisión y depuración del código*

* Empaquetado multiplataforma (Windows, macOS y Linux) *
- Reemplazar el ícono de Electron que aparece en las ventanas (en la esquina superior izquierda) por un ícono propio. ¿Es posible?
- Empaquetado para Windows, versión de prueba *
- Construir versión portable

* Conversión para aplicaciones para dispositivos moviles y kindle *

# PLAN GENERAL #

OBJETIVO DE LA APLICACIÓN
- Construir una aplicación de escritorio multiplataforma (Windows, macOS y Linux) que permita:
- Leer texto seleccionado o proveniente del portapapeles.
- Contar caracteres con espacio, sin espacio y palabras.
- Estimar tiempo de lectura usando un parámetro ajustable por el usuario.
- Usar un sistema de presets de velocidad, incluyendo:
  - Presets por defecto (ej. 180–250 WPM).
  - Presets personalizados múltiples, cada uno con nombre definido por el usuario.
  - Poder guardar nuevos presets desde el cronómetro.
- Incluir un cronómetro preciso para estimar velocidad de lectura real.
- Soporte de idiomas seleccionables para la interfaz.
- Interfaz simple, portable y fácil de mantener.

TECNOLOGÍA ELEGIDA (Propuesta original)

Tecnología base
Electron + portable build + sistema de semiauto-update mínimo.

Arquitectura
Electron con main.js, preload.js (IPC seguro) y frontend estático.

COMPONENTES

Frontend
- HTML minimalista.
- CSS simple (o Tailwind opcional).
- renderer.js para toda la lógica del UI y los llamados IPC.

Backend en Electron
- main.js: manejo de ventanas, inicialización y lógica central.
- preload.js: API segura (IPC + portapapeles + configuración).
- Persistencia con JSON.
- (Opcional) updater.js para la lógica del semiauto-update.

Empaquetado
- Portable build para Windows/Linux/macOS.
- Sin instalador.
- Carpeta final: build-output/.

Semiauto-update
- Archivo local VERSION.
- Archivo remoto con versión más reciente.
- Comparación al inicio.
- Si hay actualización: mostrar notificación y link.

